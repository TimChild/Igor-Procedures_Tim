#pragma TextEncoding = "Windows-1252"#pragma rtGlobals=3		// Use modern global access method and strict wave access.#include <Waves Average>/////////////////////////// USEFUL FUNCTIONS ///////////////////////////function setupEntropyMeasurement(instr1, instr2, vOut, freq) // units: mV, Hz	// instrument 1 is the lockin providing the voltage bias	// instrument 2 is measuring the 2nd harmonic signal	variable instr1, instr2, vOut, freq		setSRSAmplitude(instr1, vOut)	setSRSFrequency(instr1, freq)		SetSRSHarmonic(instr2,2)	SetSRSPhase(instr2,-90)endfunction transition01_37_36( xval, yval)	// 19 x + 85 y = -94845	// 19 x + 85 y = -94275	variable xval, yval		if( (19*xval + 85*yval + 94902 > 0) && (19*xval + 85*yval + 94218 < 0) )		return 1	else		return 0	endifendfunction followZeroOneVP( xval, yval)	// follows the 0-1 electron transition 	// in a sweep of VG1 vs VP1	variable xval, yval		if( (yval - 3/11*xval -17548/11 >0) && (yval - 10*xval -75 < 0) )		return 1	else		return 0	endifendfunction transition01dat705(xval, yval)	// follows the 0-1 electron transition 	// in a sweep of V	variable xval, yval		if( (yval - 10*xval + 125 >0) && (yval - 10*xval -75 < 0) )		return 1	else		return 0	endifendfunction TimDiff(yname, xname, idxStr, [averagewidth])	// yname is the name of the y-array	// xname is the name of the x-array	// idxStr is the index as a string closed in brackets	//    this is done to fool scancontroller into putting the proper index into the function	// example: LiveDiff("g_sense", "sc_xdata", "[i]")	variable averagewidth	string yname, xname, idxStr	wave ywave=$yname	wave xwave=$xname		variable i=str2num(idxStr[1,strlen(idxStr)-2])	variable n = numpnts(xwave)	int w			if (paramisdefault(averagewidth))		averagewidth=n/20	endif		w = averagewidth //didn't want to write "averagewidth" over and over	if(i<w+2)		return NaN	else		return ((ywave[i]+ywave[i-1]+ywave[i-2])/3-(ywave[i-w]+ywave[i-w-1]+ywave[i-w-2])/3)/(xwave[i]-xwave[i-w])  //averaging over 3 points on each side of a gap of width "w"	endifend	function NikDiff(yname, xname, idxStr)	// yname is the name of the y-array	// xname is the name of the x-array	// idxStr is the index as a string closed in brackets	//    this is done to fool scancontroller into putting the proper index into the function	// example: LiveDiff("g_sense", "sc_xdata", "[i]")	string yname, xname, idxStr	wave ywave=$yname	wave xwave=$xname	wave W_coef		variable i=str2num(idxStr[1,strlen(idxStr)-2])		if(i>0)		variable dx = xwave[i]-xwave[i-1]		variable min_step = 0.4		variable n = ceil(min_step/dx)				if(n<3)			n=3		endif	else		return NaN	endif	if(i<n)		return NaN	endif		duplicate/FREE/O/R=[i-n, i] ywave yn 	//makes yn with last n yvalues	Extract/FREE/O yn, yn, numtype(yn)!=0		//changes yn to be just numtypes of last n values		if(sum(yn) != 0) 		return NaN	else		CurveFit /Q line ywave[i-n,i] /X=xwave /D 		return W_coef[1]	endifend/////////////// TIME ///////////////function ReadVsTime(delay, [comments]) // Units: s	variable delay	string comments	variable i=0	if (paramisdefault(comments))		comments=""	endif	InitializeWaves(0, 1, 1, x_label="time (s)")	nvar sc_scanstarttime // Global variable set when InitializeWaves is called	do		sc_sleep(delay)		RecordValues(i, 0,readvstime=1)		i+=1	while (1)	SaveWaves(msg=comments)end///////////////////////////////         BabyDAC         ///////////////////////////////function ScanBabyDAC(instrID, start, fin, channels, numpts, delay, ramprate, [comments, nosave]) //Units: mV	// sweep one or more babyDAC channels	// channels should be a comma-separated string ex: "0, 4, 5"	variable instrID, start, fin, numpts, delay, ramprate, nosave	string channels, comments	string x_label	variable i=0, j=0, setpoint		if(paramisdefault(comments))	comments=""	endif		sprintf x_label, "BD %s (mV)", channels		// set starting values	setpoint = start	RampMultipleBD(instrID, channels, setpoint, ramprate=ramprate)		sc_sleep(1.0)	InitializeWaves(start, fin, numpts, x_label=x_label)	do		setpoint = start + (i*(fin-start)/(numpts-1))		RampMultipleBD(instrID, channels, setpoint, ramprate=ramprate)		sc_sleep(delay)		RecordValues(i, 0)		i+=1	while (i<numpts)	if (nosave == 0)  		SaveWaves(msg=comments)	endifendfunction ScanBabyDACUntil(instrID, start, fin, channels, numpts, delay, ramprate, checkwave, value, [operator, comments, scansave]) //Units: mV  // sweep one or more babyDAC channels until checkwave < (or >) value  // channels should be a comma-separated string ex: "0, 4, 5"  // operator is "<" or ">", meaning end on "checkwave[i] < value" or "checkwave[i] > value"  variable instrID, start, fin, numpts, delay, ramprate, value, scansave  string channels, operator, checkwave, comments  string x_label  variable i=0, j=0, setpoint    if(paramisdefault(comments))    comments=""  endif  if(paramisdefault(operator))    operator = "<"  endif  if(paramisdefault(scansave))    scansave=1  endif  variable a = 0  if ( stringmatch(operator, "<")==1 )    a = 1  elseif ( stringmatch(operator, ">")==1 )    a = -1  else    abort "Choose a valid operator (<, >)"  endif  sprintf x_label, "BD %s (mV)", channels  // set starting values  setpoint = start  RampMultipleBD(instrID, channels, setpoint, ramprate=ramprate)  InitializeWaves(start, fin, numpts, x_label=x_label)  sc_sleep(1.0)  wave w = $checkwave  wave resist  do    setpoint = start + (i*(fin-start)/(numpts-1))    RampMultipleBD(instrID, channels, setpoint, ramprate=ramprate)    sc_sleep(delay)    RecordValues(i, 0)    if( a*(w[i] - value) < 0 )      break    endif    i+=1  while (i<numpts)  if(scansave==1)    SaveWaves(msg=comments)  endifendfunction ScanBabyDACRepeat(instrID, startx, finx, channelsx, numptsx, delayx, rampratex, numptsy, delayy, [offsetx, comments]) //Units: mV, mT	// x-axis is the dac sweep	// y-axis is an index	// this will sweep: start -> fin, fin -> start, start -> fin, ....	// each sweep (whether up or down) will count as 1 y-index		variable instrID, startx, finx, numptsx, delayx, rampratex, numptsy, delayy, offsetx	string channelsx, comments	variable i=0, j=0, setpointx, setpointy	string x_label, y_label		if(paramisdefault(comments))		comments=""	endif		if( ParamIsDefault(offsetx))		offsetx=0	endif	// setup labels	sprintf x_label, "BD %s (mV)", channelsx	y_label = "Sweep Num"		// intialize waves	variable starty = 0, finy = numptsy-1, scandirection=0	InitializeWaves(startx, finx, numptsx, starty=starty, finy=finy, numptsy=numptsy, x_label=x_label, y_label=y_label)		// set starting values	setpointx = startx-offsetx	RampMultipleBD(instrID, channelsx, setpointx, ramprate=rampratex)	sc_sleep(2.0)		do		if(mod(i,2)==0)			j=0			scandirection=1		else			j=numptsx-1			scandirection=-1		endif				setpointx = startx - offsetx + (j*(finx-startx)/(numptsx-1)) // reset start point		RampMultipleBD(instrID, channelsx, setpointx, ramprate=rampratex)		sc_sleep(delayy) // wait at start point		do			setpointx = startx - offsetx + (j*(finx-startx)/(numptsx-1))			RampMultipleBD(instrID, channelsx, setpointx, ramprate=rampratex)			sc_sleep(delayx)			RecordValues(i, j)			j+=scandirection		while (j>-1 && j<numptsx)		i+=1	while (i<numptsy)	SaveWaves(msg=comments)endfunction ScanBabyDAC2D(instrID, startx, finx, channelsx, numptsx, delayx, rampratex, starty, finy, channelsy, numptsy, delayy, rampratey, [comments]) //Units: mV  variable instrID, startx, finx, numptsx, delayx, rampratex, starty, finy, numptsy, delayy, rampratey  string channelsx, channelsy, comments  variable i=0, j=0, setpointx, setpointy  string x_label, y_label  if(paramisdefault(comments))    comments=""  endif  sprintf x_label, "BD %s (mV)", channelsx  sprintf y_label, "BD %s (mV)", channelsy  // set starting values  setpointx = startx  setpointy = starty  RampMultipleBD(instrID, channelsx, setpointx, ramprate=rampratex)  RampMultipleBD(instrID, channelsy, setpointy, ramprate=rampratey)  // initialize waves  InitializeWaves(startx, finx, numptsx, starty=starty, finy=finy, numptsy=numptsy, x_label=x_label, y_label=y_label)    // main loop  do    setpointx = startx    setpointy = starty + (i*(finy-starty)/(numptsy-1))    RampMultipleBD(instrID, channelsy, setpointy, ramprate=rampratey)    RampMultipleBD(instrID, channelsx, setpointx, ramprate=rampratex)    sc_sleep(delayy)    j=0    do      setpointx = startx + (j*(finx-startx)/(numptsx-1))      RampMultipleBD(instrID, channelsx, setpointx, ramprate=rampratex)      sc_sleep(delayx)      RecordValues(i, j)      j+=1    while (j<numptsx)    i+=1  while (i<numptsy)  SaveWaves(msg=comments)endfunction ScanBabyDAC2Dcut(instrID, startx, finx, channelsx, numptsx, delayx, rampratex, starty, finy, channelsy, numptsy, delayy, rampratey, func, [comments]) //Units: mV  variable instrID, startx, finx, numptsx, delayx, rampratex, starty, finy, numptsy, delayy, rampratey  string channelsx, channelsy, func, comments  variable i=0, j=0, setpointx, setpointy  string x_label, y_label  if(paramisdefault(comments))    comments=""  endif  FUNCREF cutFunc fcheck=$func  sprintf x_label, "BD %s (mV)", channelsx  sprintf y_label, "BD %s (mV)", channelsy  // initialize waves  InitializeWaves(startx, finx, numptsx, starty=starty, finy=finy, numptsy=numptsy, x_label=x_label, y_label=y_label)  sc_sleep(1.0)    	// main loop	do		j=0		setpointx = startx		setpointy = starty + (i*(finy-starty)/(numptsy-1))				do			setpointx = startx + (j*(finx-startx)/(numptsx-1))			if( fcheck(setpointx, setpointy) == 0 )				RecordValues(i, j, fillnan=1)				j+=1			else				break			endif		while( j<numptsx )				if (j == numptsx)			i+=1			continue		endif	  	  	RampMultipleBD(instrID, channelsy, setpointy, ramprate=rampratey)  		RampMultipleBD(instrID, channelsx, setpointx, ramprate=rampratex)		sc_sleep(delayy)				do		  setpointx = startx + (j*(finx-startx)/(numptsx-1))		  if( fcheck(setpointx, setpointy) == 0 )		     RecordValues(i, j, fillnan=1)		  else    		  RampMultipleBD(instrID, channelsx, setpointx, ramprate=rampratex)		     sc_sleep(delayx)		     RecordValues(i, j)		  endif		  j+=1		while (j<numptsx)		i+=1	while (i<numptsy)	  SaveWaves(msg=comments)endfunction ScanBabyDAC3D(instrID, start, fin, channels, numpts, delay, ramprate, [comments]) //Units: mV  // sweep one or more babyDAC channels  // channels should be a comma-separated string ex: "0, 4, 5"  // measure a 2D scan at each setpoint  variable instrID, start, fin, numpts, delay, ramprate  string channels, comments  string x_label  variable i=0, j=0, setpoint  if(paramisdefault(comments))    comments=""  endif  sprintf x_label, "BD %s (mV)", channels  // set starting values  setpoint = start  RampMultipleBD(instrID, channels, setpoint, ramprate=ramprate)  sc_sleep(1.0)  do    setpoint = start + (i*(fin-start)/(numpts-1))    RampMultipleBD(instrID, channels, setpoint, ramprate=ramprate)    sc_sleep(delay)	ScanBabyDAC2D(instrID, -3200, -5000, "12", 181, 0.1, 1000, -550, -250, "13", 61, 0.3, 1000)	i+=1  while (i<numpts)end////////////// SRS //////////////function ScanBabyDAC_SRS(babydacID, srsID, startx, finx, channelsx, numptsx, delayx, rampratex, starty, finy, numptsy, delayy, [comments]) //Units: mV, mV  variable babydacID, srsID, startx, finx, numptsx, delayx, rampratex, starty, finy, numptsy, delayy  string channelsx, comments  variable i=0, j=0, setpointx, setpointy  string x_label, y_label  if(paramisdefault(comments))    comments=""  endif  sprintf x_label, "BD %s (mV)", channelsx  sprintf y_label, "SRS%d (mV)", getAddressGPIB(srsID)  // set starting values  setpointx = startx  setpointy = starty  RampMultipleBD(babydacID, channelsx, setpointx, ramprate=rampratex)  SetSRSAmplitude(srsID,setpointy)  // initialize waves  InitializeWaves(startx, finx, numptsx, starty=starty, finy=finy, numptsy=numptsy, x_label=x_label, y_label=y_label)    // main loop  do    setpointx = startx    setpointy = starty + (i*(finy-starty)/(numptsy-1))    RampMultipleBD(babydacID, channelsx, setpointx, ramprate=rampratex)    SetSRSAmplitude(srsID,setpointy)    sc_sleep(delayy)    j=0    do      setpointx = startx + (j*(finx-startx)/(numptsx-1))      RampMultipleBD(babydacID, channelsx, setpointx, ramprate=rampratex)      sc_sleep(delayx)      RecordValues(i, j)      j+=1    while (j<numptsx)    i+=1  while (i<numptsy)  SaveWaves(msg=comments)  endfunction ScanBabyDAC_freq(babydacID, srsID, startx, finx, channelsx, numptsx, delayx, rampratex, starty, finy, numptsy, delayy, [comments]) //Units: mV, mV  variable babydacID, srsID, startx, finx, numptsx, delayx, rampratex, starty, finy, numptsy, delayy  string channelsx, comments  variable i=0, j=0, setpointx, setpointy  string x_label, y_label  if(paramisdefault(comments))    comments=""  endif  sprintf x_label, "BD %s (mV)", channelsx  sprintf y_label, "SRS%d (mV)", getAddressGPIB(srsID)  // set starting values  setpointx = startx  setpointy = starty  RampMultipleBD(babydacID, channelsx, setpointx, ramprate=rampratex)  SetSRSFrequency(srsID,setpointy)  // initialize waves  InitializeWaves(startx, finx, numptsx, starty=starty, finy=finy, numptsy=numptsy, x_label=x_label, y_label=y_label)    // main loop  do    setpointx = startx    setpointy = starty + (i*(finy-starty)/(numptsy-1))    RampMultipleBD(babydacID, channelsx, setpointx, ramprate=rampratex)    SetSRSFrequency(srsID,setpointy)    sc_sleep(delayy)    j=0    do      setpointx = startx + (j*(finx-startx)/(numptsx-1))      RampMultipleBD(babydacID, channelsx, setpointx, ramprate=rampratex)      sc_sleep(delayx)      RecordValues(i, j)      j+=1    while (j<numptsx)    i+=1  while (i<numptsy)  SaveWaves(msg=comments)  end////////////////////// TEMPERATURE //////////////////////function WaitTillTempStable(instrID, targetTmK, times, delay, err)	// instrID is the lakeshore controller ID	// targetmK is the target temperature in mK	// times is the number of readings required to call a temperature stable	// delay is the time between readings	// err is a percent error that is acceptable in the readings	string instrID	variable targetTmK, times, delay, err	variable passCount, targetT=targetTmK/1000, currentT = 0		// check for stable temperature	print "Target temperature: ", targetTmK, "mK"		variable j = 0	for (passCount=0; passCount<times; )		sc_sleep(delay)		for (j = 0; j<10; j+=1)			sc_sleep(1.0)			currentT += getLS370temp(instrID, "mc")/10 // do some averaging			sc_sleep(1.0)		endfor		if (ABS(currentT-targetT) < err*targetT)			passCount+=1			print "Accepted", passCount, " @ ", currentT, "K"		else			print "Rejected", passCount, " @ ", currentT, "K"			passCount = 0		endif		currentT = 0	endforendmacro step_temp_scanSomething()//	make/o targettemps =  {200, 175, 150, 125, 100, 80, 60, 40}//	make/o heaterranges = {3.1, 3.1, 3.1, 3.1, 3.1, 3.1, 3.1, 1}	make/o targettemps =  {200, 150, 100, 70, 40}	make/o heaterranges = {3.1, 3.1, 3.1, 3.1, 1}	setLS370exclusivereader(ls370,"bfsmall_mc")			rampMultipleBD(bd6, "0", 100, ramprate=1000) 	variable i=0	do		setLS370PIDcontrol(ls370,6,targettemps[i],heaterranges[i])		sc_sleep(2.0)				WaitTillTempStable(ls370, targettemps[i], 5, 20, 0.10)		sc_sleep(60.0)				print "MEASURE AT: "+num2str(targettemps[i])+"mK"				//ScanVirtualGateVP1Repeat(bd6, -35, 35, 701, 0.1, 8, 0.3)			//ScanBabyDACRepeat(bd6, -2668-25, -2668+25, "12", 501, 0.1, 1000, 11, 0.3)				//ScanBabyDACRepeat(bd6, -2311-10, -2311+10, "12", 201, 0.1, 1000, 10, 0.3)		ScanBabyDac2D(bd6, -2596-30, -2596+30, "12", 601, 0.03, 1000, -500, 500, "0", 101, 0.5, 1000)				i+=1	while ( i<numpnts(targettemps) )		// kill temperature control	turnoffLS370MCheater(ls370)	resetLS370exclusivereader(ls370)		sc_sleep(60.0*30)	//ScanVirtualGateVP1Repeat(bd6, -35, 35, 701, 0.1, 8, 0.3)	//ScanBabyDACRepeat(bd6, -2668-25, -2668+25, "12", 501, 0.1, 1000, 11, 0.3)		//ScanBabyDACRepeat(bd6, -2311-10, -2311+10, "12", 201, 0.1, 1000, 10, 0.3)	ScanBabyDac2D(bd6, -2596-30, -2596+30, "12", 601, 0.03, 1000, -500, 500, "0", 101, 0.5, 1000)end//////////////////////// VIRTUAL GATES ////////////////////////// OLD VIRTUAL GATES/////////////////////////function define_virtual_gate_origin()//	// this function defines the virtual gate origin in a wave//	make /o virtual_gate_origin = {48,1170,0,0,0,-238,-630,-510,-2198,-630,-630,-400,-3972,-460,-400,-1100}//end////function define_virtual_gate_couplings()//	// this function defines the virtual gate couplings//	make /o virtual_gate_couplings = {{1,0.7605,0,0},{0.08998,0.9912,0,0},{3.8830,6.1527,1,0},{3.9904,1.4254,0,1}}//	matrixop /o inv_gate_couplings = inv(virtual_gate_couplings)//end///////////////////////////////////////function define_virtual_gate_origin()	// this function defines the virtual gate origin in a wave	make /o virtual_gate_origin = {0,1150,0,-25,0,-238,-630,-510,-2190,-630,-630,-275,-4091,-390,-400,-995}endfunction define_virtual_gate_couplings()	// this function defines the virtual gate couplings	make /o virtual_gate_couplings = {{0.981,0.681,0,0},{0.133,0.936,0,0},{3.938,7.419,1,0},{3.69,1.32,0,1}}	matrixop /o inv_gate_couplings = inv(virtual_gate_couplings)end//ScanVirtualGates2D(bd6, -8, 10, "VP1", 181, 0.3, -5, 5, "VP1", 3, 1.0, vp2=4)function reset_gates_to_origin(instrID)	// resets all the gates to the point from which the virtual gates are defined	// only changes DAC5-14	// channels 0-4 are biases and unused channels	// channel 15 controls the heater QPC and should have a minimal coupling to the dots	variable instrID	define_virtual_gate_origin()	wave vgo = virtual_gate_origin		variable i=0	for(i=5;i<15;i+=1)		RampOutputBD(instrID, i, vgo[i])	endforendfunction RampVirtualGates(instrID, GateKeyString)	// example GateKeyString = "VP1:0;VP2:0;VG1:0;VG2:0"	// vp_small and vp_big are deltas	// both virtual gates are equal to zero at the virtual gate origin	variable instrID	String GateKeyString		variable vp_small, vp_big, vg_coup, vg_res		vp_small = NumberByKey("VP1", GateKeyString)	vp_big = NumberByKey("VP2", GateKeyString)	vg_coup = NumberByKey("VG1", GateKeyString)	vg_res = NumberByKey("VG2", GateKeyString)		if(numtype(vp_small)!=0 || numtype(vp_big)!=0 || numtype(vg_coup)!=0 || numtype(vg_res)!=0)		print GateKeyString		abort("Incorrect format for GateKeyString. Should be e.g. 'VP1:0;VP2:0;VG1:0;VG2:0'")	endif		wave vgo = virtual_gate_origin	wave igc = inv_gate_couplings	make /o vg_deltas = {vp_small, vp_big, vg_coup, vg_res}	MatrixOP /o gate_deltas = igc x vg_deltas//	print vgo[12]+gate_deltas[0], vgo[8]+gate_deltas[1], vgo[11]+gate_deltas[2], vgo[13]+gate_deltas[3]	RampOutputBD(instrID, 12, vgo[12]+gate_deltas[0], ramprate=1000)//	sc_sleep(0.01)	RampOutputBD(instrID, 8, vgo[8]+gate_deltas[1], ramprate=1000)//	sc_sleep(0.01)	RampOutputBD(instrID, 11, vgo[11]+gate_deltas[2], ramprate=1000)//	sc_sleep(0.01)	RampOutputBD(instrID, 13, vgo[13]+gate_deltas[3], ramprate=1000)//	sc_sleep(0.01)	endfunction checkgatevalid(gate)	string gate	string gatelist="VP1;VP2;VG1;VG2"	int i=0		for (i=0; i<4; i+=1)		if (cmpstr(gate, stringfromlist(i, gatelist))==0)			return 1		endif	endfor	abort("One of the Gate choices was invalid")endfunction ScanVirtualGates2D(instrID, startx, finx, xgate, numptsx, delayx, starty, finy, ygate, numptsy, delayy, [vp1, vp2, vg1, vg2,comments]) //Units: mV	// Coupling between dots in x	// small dot transitions in y	variable instrID, startx, finx, numptsx, delayx, starty, finy, numptsy, delayy, vp1, vp2, vg1, vg2	string xgate, ygate, comments	variable i=0, j=0, setpointx, setpointy	string x_label="", y_label="", GKS="" //GateKeyString		checkgatevalid(xgate)	checkgatevalid(ygate)			if (cmpstr(xgate, ygate) == 0)		abort("x and y gates were equal")	endif			if(paramisdefault(comments))		comments=""	endif	  	if(ParamIsDefault(vp1))		vp1=0	elseif (cmpstr(xgate, "VP1")==0 || cmpstr(ygate, "VP1")==0)		abort("optional gate same as x or y gate")	endif  	if(ParamIsDefault(vp2))		vp2=0	elseif (cmpstr(xgate, "VP2")==0 || cmpstr(ygate, "VP2")==0)		abort("optional gate same as x or y gate")	endif  		if(ParamIsDefault(vg1))		vg1=0	elseif (cmpstr(xgate, "VG1")==0 || cmpstr(ygate, "VG1")==0)		abort("optional gate same as x or y gate")	endif  		if(ParamIsDefault(vg2))		vg2=0	elseif (cmpstr(xgate, "VG2")==0 || cmpstr(ygate, "VG2")==0)		abort("optional gate same as x or y gate")	endif		GKS = replaceNumberByKey("VP1", GKS, vp1)	GKS = replaceNumberByKey("VP2", GKS, vp2)	GKS = replaceNumberByKey("VG1", GKS, vg1)	GKS = replaceNumberByKey("VG2", GKS, vg2)		setpointx = startx	setpointy = starty	GKS = replaceNumberByKey(xgate, GKS, setpointx)	GKS = replacenumberByKey(ygate, GKS, setpointy)			sprintf x_label, xgate	sprintf y_label, ygate		// set starting values	define_virtual_gate_origin()	define_virtual_gate_couplings()		RampVirtualGates(instrID, GKS)	sc_sleep(4.0)		// initialize waves	InitializeWaves(startx, finx, numptsx, starty=starty, finy=finy, numptsy=numptsy, x_label=x_label, y_label=y_label)		// main loop	do		setpointx = startx		setpointy = starty + (i*(finy-starty)/(numptsy-1))		GKS = replaceNumberByKey(xgate, GKS, setpointx)		GKS = replacenumberByKey(ygate, GKS, setpointy)		RampVirtualGates(instrID, GKS)		sc_sleep(delayy)		j=0		do		  setpointx = startx + (j*(finx-startx)/(numptsx-1))		  GKS = replacenumberByKey(xgate, GKS, setpointx)		  RampVirtualGates(instrID, GKS)		  sc_sleep(delayx)		  RecordValues(i, j)		  j+=1		while (j<numptsx)		i+=1	while (i<numptsy)	SaveWaves(msg=comments)endfunction ScanVirtualGate(instrID, startx, finx, xgate, numptsx, delayx, [vp1, vp2, vg1, vg2,comments]) //Units: mV	variable instrID, startx, finx, numptsx, delayx, vp1, vp2, vg1, vg2	string xgate, comments	variable j=0, setpointx	string x_label="", GKS="" //GateKeyString		checkgatevalid(xgate)			if(paramisdefault(comments))		comments=""	endif	  	if(ParamIsDefault(vp1))		vp1=0	elseif (cmpstr(xgate, "VP1")==0)		abort("optional gate same as x gate")	endif  	if(ParamIsDefault(vp2))		vp2=0	elseif (cmpstr(xgate, "VP2")==0)		abort("optional gate same as x gate")	endif  		if(ParamIsDefault(vg1))		vg1=0	elseif (cmpstr(xgate, "VG1")==0)		abort("optional gate same as x gate")	endif  		if(ParamIsDefault(vg2))		vg2=0	elseif (cmpstr(xgate, "VG2")==0)		abort("optional gate same as x gate")	endif		GKS = replaceNumberByKey("VP1", GKS, vp1)	GKS = replaceNumberByKey("VP2", GKS, vp2)	GKS = replaceNumberByKey("VG1", GKS, vg1)	GKS = replaceNumberByKey("VG2", GKS, vg2)		setpointx = startx	GKS = replaceNumberByKey(xgate, GKS, setpointx)			sprintf x_label, xgate		// set starting values	define_virtual_gate_origin()	define_virtual_gate_couplings()		RampVirtualGates(instrID, GKS)	sc_sleep(4.0)		// initialize waves	InitializeWaves(startx, finx, numptsx, x_label=x_label)		// main loop	do	  setpointx = startx + (j*(finx-startx)/(numptsx-1))	  GKS = replacenumberByKey(xgate, GKS, setpointx)	  RampVirtualGates(instrID, GKS)	  sc_sleep(delayx)	  RecordValues(j,0)	  j+=1	while (j<numptsx)	SaveWaves(msg=comments)endfunction ScanVirtualGateRepeat(instrID, startx, finx, xgate, numptsx, delayx, numptsy, delayy, [vp1, vp2, vg1, vg2,comments]) //Units: mV	// Coupling between dots in x	// small dot transitions in y	variable instrID, startx, finx, numptsx, delayx, numptsy, delayy, vp1, vp2, vg1, vg2	string xgate, comments	variable i=0, j=0, setpointx, starty=1, finy=numptsy	string x_label="", y_label="Repeats", GKS="" //GateKeyString		checkgatevalid(xgate)		if(paramisdefault(comments))		comments=""	endif	  	if(ParamIsDefault(vp1))		vp1=0	elseif (cmpstr(xgate, "VP1")==0)		abort("optional gate same as x gate")	endif  	if(ParamIsDefault(vp2))		vp2=0	elseif (cmpstr(xgate, "VP2")==0)		abort("optional gate same as x gate")	endif  		if(ParamIsDefault(vg1))		vg1=0	elseif (cmpstr(xgate, "VG1")==0)		abort("optional gate same as x gate")	endif  		if(ParamIsDefault(vg2))		vg2=0	elseif (cmpstr(xgate, "VG2")==0)		abort("optional gate same as x gate")	endif		GKS = replaceNumberByKey("VP1", GKS, vp1)	GKS = replaceNumberByKey("VP2", GKS, vp2)	GKS = replaceNumberByKey("VG1", GKS, vg1)	GKS = replaceNumberByKey("VG2", GKS, vg2)		setpointx = startx		GKS = replaceNumberByKey(xgate, GKS, setpointx)			sprintf x_label, xgate		// set starting values	define_virtual_gate_origin()	define_virtual_gate_couplings()		RampVirtualGates(instrID, GKS)	sc_sleep(4.0)		// initialize waves	InitializeWaves(startx, finx, numptsx, starty=starty, finy=finy, numptsy=numptsy, x_label=x_label, y_label=y_label)		// main loop	do		setpointx = startx		GKS = replaceNumberByKey(xgate, GKS, setpointx)		RampVirtualGates(instrID, GKS)		sc_sleep(delayy)		j=0		do		  setpointx = startx + (j*(finx-startx)/(numptsx-1))		  GKS = replacenumberByKey(xgate, GKS, setpointx)		  RampVirtualGates(instrID, GKS)		  sc_sleep(delayx)		  RecordValues(i, j)		  j+=1		while (j<numptsx)		i+=1	while (i<numptsy)	SaveWaves(msg=comments)endfunction cutFunc(xval, yval)	// this function is a template needed for the scan function defined below	variable xval,yvalendfunction ScanVirtualGates2Dcut(instrID, startx, finx, xgate, numptsx, delayx, starty, finy, ygate, numptsy, delayy, func, [vp1, vp2, vg1, vg2,comments]) //Units: mV	// Coupling between dots in x	// small dot transitions in y	variable instrID, startx, finx, numptsx, delayx, starty, finy, numptsy, delayy, vp1, vp2, vg1, vg2	string xgate, ygate, func, comments	variable i=0, j=0, setpointx, setpointy	string x_label="", y_label="", GKS="" //GateKeyString		FUNCREF cutFunc fcheck=$func		checkgatevalid(xgate)	checkgatevalid(ygate)			if (cmpstr(xgate, ygate) == 0)		abort("x and y gates were equal")	endif			if(paramisdefault(comments))		comments=""	endif	  	if(ParamIsDefault(vp1))		vp1=0	elseif (cmpstr(xgate, "VP1")!=0 || cmpstr(ygate, "VP1")!=0)		abort("optional gate same as x or y gate")	endif  	if(ParamIsDefault(vp2))		vp2=0	elseif (cmpstr(xgate, "VP2")!=0 || cmpstr(ygate, "VP2")!=0)		abort("optional gate same as x or y gate")	endif  		if(ParamIsDefault(vg1))		vg1=0	elseif (cmpstr(xgate, "VG1")!=0 || cmpstr(ygate, "VG1")!=0)		abort("optional gate same as x or y gate")	endif  		if(ParamIsDefault(vg2))		vg2=0	elseif (cmpstr(xgate, "VG2")!=0 || cmpstr(ygate, "VG2")!=0)		abort("optional gate same as x or y gate")	endif		GKS = replaceNumberByKey("VP1", GKS, vp1)	GKS = replaceNumberByKey("VP2", GKS, vp2)	GKS = replaceNumberByKey("VG1", GKS, vg1)	GKS = replaceNumberByKey("VG2", GKS, vg2)		setpointx = startx	setpointy = starty	GKS = replaceNumberByKey(xgate, GKS, setpointx)	GKS = replacenumberByKey(ygate, GKS, setpointy)			sprintf x_label, xgate	sprintf y_label, ygate		// set starting values	define_virtual_gate_origin()	define_virtual_gate_couplings()		RampVirtualGates(instrID, GKS)	sc_sleep(4.0)		// initialize waves	InitializeWaves(startx, finx, numptsx, starty=starty, finy=finy, numptsy=numptsy, x_label=x_label, y_label=y_label)		// main loop	do		j=0		setpointx = startx		setpointy = starty + (i*(finy-starty)/(numptsy-1))				do			setpointx = startx + (j*(finx-startx)/(numptsx-1))			if( fcheck(setpointx, setpointy) == 0 && j<numptsx)				RecordValues(i, j, fillnan=1)				j+=1			else				break			endif		while( 1 )				if (j == numptsx)			i+=1			continue		endif				GKS = replacenumberByKey(ygate, GKS, setpointy)	   GKS = replacenumberByKey(xgate, GKS, setpointx)	   RampVirtualGates(instrID, GKS)		sc_sleep(delayy)				do		  setpointx = startx + (j*(finx-startx)/(numptsx-1))		  if( fcheck(setpointx, setpointy) == 0 )		     RecordValues(i, j, fillnan=1)		  else		     GKS = replacenumberByKey(xgate, GKS, setpointx)		     RampVirtualGates(instrID, GKS)		     sc_sleep(delayx)		     RecordValues(i, j)		  endif		  j+=1		while (j<numptsx)				i+=1	while (i<numptsy)	SaveWaves(msg=comments)end////////////////////////// tests /// Tim's //////////////////////////Function TimsFunctions() //So I can find where this starts...Endfunction test()	string/g zVKS = ""	zVKS = replacenumberByKey("x1", zVKS, 10)	print zVKSEndfunction test2()	svar/z VKS = $getVKS()	print VKS	VKS = replaceNumberByKey("x2", VKS, 15)	print VKSendFunction/S GetVKS()    SVAR/Z zVKS  //SDFR SetDataFolderReference    if(!SVAR_Exists(zVKS))        string/G zVKS   // zVKS = VariableKeyString (z so at bottom of data folder)    endif    return "zVKS"Endfunction Cut2Dline(x, y, [followtolerance]) //tests if x, y lie within lines defined in VKS. Returns 1 for Yes, 0 for No	//followtolerance will adapt line equation up to tolerance (0.1 = 10% change)	variable x, y, followtolerance	svar VKS = $GetVKS() 	//VariableKeyString (global so it can storechanges)   VKS = "m; HighC; LowC; x1; x2; y1; y2" 		variable m, HighC, LowC, ft = followtolerance, n  //High/Low for the two y = mx+c equations		m = numberbykey("m", VKS)	HighC = numberbykey("HighC", VKS)	LowC = numberbykey("LowC", VKS)	n = numberbykey("n", VKS) //Used for followfunction		//caluclates Line equation from coords or previous data lines if necessary	if (numtype(m)!=0 || numtype(HighC)!=0 || numtype(LowC)!=0 || n >= 2)  //Calculating line equations if necessary		variable x1, x2, y1, y2, w //for calculating y = mx + c equations			w = numberbykey("w", VKS)		if(n == 0 || numtype(n) == 2) //For first time or if n is not set and defaults to NaN			x1 = numberbykey("x1", VKS)			x2 = numberbykey("x2", VKS)			y1 = numberbykey("y1", VKS)			y2 = numberbykey("y2", VKS)			elseif(ft == 0 && n >= 2) //If no finite tolerance			n = -2 			//will stop Cut2Dline from storing junk data into VKS			VKS = replacenumberbykey("n", VKS, -1) //when n = -1 is loaded next time it won't try calculate new eq		elseif(n >= 2 && ft!= 0) //enough rows to calculate new coords and finite tolerance			wave i_sense2d, w_coef, sc_ydata, sc_linestart	//Fits to charge transition from charge sensor, funcfit stores values in W_coef, sc_ywave has y values of data, sc_linestart has first x position of isense_2d data			nvar sc_is2d						variable i = 0, nend						if(n < (ceil(5/dimdelta(sc_ydata,0))) && dimdelta(sc_ydata,0) < 2.5) //If there isn't enough data to do 5mV in y direction use all gathered so far				nend = n			elseif (dimdelta(sc_ydata,0)<2.5) //otherwise use enough data to cover 5mV				nend = ceil(5/dimdelta(sc_ydata,0))			else				nend = 2 // if ydata is sparse (i.e. quick scan) just use previous two points for gradient			endif							make/Free/O/N=(nend,2) coords = NaN	 //to store multiple transition coords				do //Find previous x and y coords of transitions				duplicate/FREE/O/RMD=[][(n-1)-i] i_sense2d datrow				if(sc_is2d == 2) //only necessary for line cut					setscale/P x, sc_linestart[(n-1)-i], dimdelta(i_sense2d, 0), datrow //Need to give correct dimensions before fitting				endif				coords[i][0] = fitcharge1d(datrow)				coords[i][1] = sc_ydata[(n-1)-i] 				i+=1			while (i<nend)						wavestats/Q/M=1/RMD=[][0] coords			if(V_numnans/dimsize(coords,0) < 0.5 && dimsize(coords,0) - V_numNans >= 2) //if at least 50% successful fits	and at least two data points make and check new m and Cs						curveFit/Q line, coords[][1] /X=coords[][0]				m = w_coef[1] 						//new gradient from linefit									variable oldm, TE // TE for ToleranceExceedNum number that I store in VKS				oldm = numberbykey("m", VKS)				TE = numberbykey("TolExceedNum", VKS) //Loads previous error code stored (NaN by default)				if(numtype(TE) == 2) //Sets TE to zero if first time being loaded					TE = 0				elseif(TE > 0.4)					TE = TE-0.4 		//so that E only causes abort if maxes out 3 times in a row, or more than ~40% of the time				endif				// Check to see if m has changed more than allowed by tolerance (Probably won't handle stationary points)				if(abs((m-oldm)/oldm) > ft)					print "[WARNING]: Cut2Dline thinks line gradient should change by " +num2str(((m-oldm)/oldm)*100) + "% at n = " + num2str(n) + ", with Total Error now at " + num2str(TE+1)					m = oldm*(1+sign(abs(m)-abs(oldm))*ft) //increases/decreases m by max allowed amount					TE += 1 //increment Error value//				else//					print "m changed by " + num2str(((m-oldm)/oldm)*100) + "% at n = " + num2str(n)				endif				if(TE>5)					savewaves()					abort "Cut2Dline has changed gradient by max tolerance too many times in a row"				endif				VKS = replacenumberbykey("TolExceedNum", VKS, TE) //Stores total errors				VKS = replacenumberbykey("n", VKS, -1) //Prevent re-running this whole chunk of code until a new n value is stored by scan function								i = 0				do //get most recent nonNan transition coord					x1 = coords[i][0]; y1 = coords[i][1]					i+=1				while(numtype(x1)==2 && i<nend)				if(numtype(x1) == 0) //If good coord then calc high and low C					HighC = y1-m*(x1-sign(m)*w/2) 	//					LowC = y1-m*(x1+sign(m)*w/2)		//				else					savewaves()					abort "Can't find x1, y1 to calc new C values"				endif							else				VKS = replacenumberbykey("n", VKS, -1) //don't calc again until new row of data				n=-2	//don't store junk data in VKS			endif			//			duplicate/FREE/O/RMD=[][n-2] i_sense2d datrow  //previous row of data (assuming i_sense2d does not have correct x start values as it's 2DLine data//			if(sc_is2d == 2) //only necessary for line cut//				setscale/P x, sc_linestart[n-2], dimdelta(i_sense2d, 0), datrow //Need to give correct dimensions before fitting//			endif//			x1 = fitcharge1d(datrow)//			if(numtype(x1)!=NaN)//				y1 = sc_ydata[n-2]  //Y value of previous row of data//				duplicate/FREE/O/RMD=[][n-1] i_sense2d datrow //row of data just taken//				if(sc_is2d == 2) //only necessary for line cut//					setscale/P x, sc_linestart[n-1], dimdelta(i_sense2d, 0), datrow //Need to give correct dimensions before fitting//				endif//				x2 = fitcharge1d(datrow)//				y2 = sc_ydata[n-1]	//Y value of data just taken//			endif			else			abort "Cut2Dline Failed unexpectedly"		endif						if(n == 0 || numtype(n) == 2) //if first time through or not using n			m = ((y2-y1)/(x2-x1))			HighC = y1-m*(x1-sign(m)*w/2) //sign(m) makes it work for +ve or -ve gradient			LowC = y1-m*(x1+sign(m)*w/2)	//For both y = mx + c equations		endif		//		if((numtype(x2) != 2 && numtype(x1) != 2) || n == 0 || numtype(n) == 2)	//Calc line params if good chargetransition fits or first time through (or n not used = NaN)//			m = ((y2-y1)/(x2-x1))//			HighC = y1-m*(x1-sign(m)*w/2) //sign(m) makes it work for +ve or -ve gradient//			LowC = y1-m*(x1+sign(m)*w/2)	//For both y = mx + c equations//		elseif(numtype(x1) == 2 || numtype(x2) == 2) //if FindTransitionMid failed to accurately fine one of the transitions//			if(numtype(numberbykey("BadFits", VKS)) == 2) //initializes no. Badfits if necessary//				VKS = replacenumberbykey("BadFits", VKS, 0)//			endif//			VKS = replacenumberbykey("BadFits", VKS, (numberbykey("Badfits", VKS)+1))	//increments counter for number of times 1D charge transition failed to fit (for testing purposes)//			print "FindTransitionMid Failed at row " +num2str(n-1)//			VKS = replacenumberbykey("n", VKS, -1) //will wait until new line of data//			n = -2 //don't bother storing parameters again//		endif				//		//Check new cut function within tolerance//		if(n !=0 && numtype(n) != 2 && (numtype(x1) == 0 && numtype(x2) == 0)) //if not first time, and FindTransitionMid returned real values//			//check new m doesn't vary by more than tolerance//			variable oldm, TE // TE for ToleranceExceedNum number that I store in VKS//			oldm = numberbykey("m", VKS)//			TE = numberbykey("TolExceedNum", VKS) //Loads previous error code stored (NaN by default)//			if(numtype(TE) == 2) //Sets E to zero if first time being loaded//				TE = 0//			elseif(TE > 0.4)//				TE = TE-0.4 //so that E only causes abort if maxes out 3 times in a row, or more than ~40% of the time//			endif//			// Check to see if m has changed more than allowed by tolerance (Probably won't handle stationary points)//			if(abs((m-oldm)/oldm) > ft)//				print "[WARNING]: Cut2Dline thinks line gradient should change by " +num2str(((m-oldm)/oldm)*100) + "% at n = " + num2str(n) + ", with Total Error now at " + num2str(TE+1)//				m = oldm*(1+sign(abs(m)-abs(oldm))*ft) //increases/decreases m by max allowed amount//				HighC = y1-m*(x1-sign(m)*w/2) //recalculate High and LowC for new m value//				LowC = y1-m*(x1+sign(m)*w/2)	//				TE += 1 //increment Error value//			else//				//print "m changed by " + num2str(((m-oldm)/oldm)*100) + "% at n = " + num2str(n)//			endif//			if(TE>5)//				abort "Cut2Dline has changed gradient by max tolerance too many times in a row"//			endif//			VKS = replacenumberbykey("TolExceedNum", VKS, TE) //Stores total errors//			VKS = replacenumberbykey("n", VKS, -1) //Prevent re-running this whole chunk of code until a new n value is stored by scan function//		endif				//If sanity checks passed/values made acceptable, or just first time through then store values		if(n != -2 ) //use this to prevent storing values			VKS = replacenumberbykey("m", VKS, m)				//stores line eq back in VKS			VKS = replacenumberbykey("HighC", VKS, HighC)			VKS = replacenumberbykey("LowC", VKS, LowC)				VKS = replacenumberbykey("n", VKS, -1) //prevent recalculating until new data row		endif	endif		//Part that actually checks if x, y coords should be measured	if ((y - m*x - LowC) > 0 && (y - m*x - HighC) < 0)		return 1	else		return 0	endif		endfunction ScanBabyDac2DLine(instrID, startx, finx, channelsx, stepmultiple, delayx, rampratex, starty, finy, channelsy, numptsy, delayy, rampratey, width, [x1, y1, x2, y2, comments, linecut, followtolerance]) //Units: mV	variable instrID, startx, finx, stepmultiple, delayx, rampratex, starty, finy, numptsy, delayy, rampratey, x1, y1, x2, y2, width, linecut, followtolerance									string channelsx, channelsy, comments	variable i=0, j=0, setpointx, setpointy, ft = followtolerance, numptsx	string x_label, y_label	svar VKS = $getVKS()  //Global VariableKeyString so it can be passed and altered by the function (e.g. Cut2Dlines)	VKS = ""  // Reset global string		if((finx - startx)/(stepmultiple*0.076) < 20) //Easy to forget that it is stepmultiple instead of numptsx		doAlert/T="Check stepmultiple (not numptsx here!)" 1, "Do you really want to run a scan with only "\			+ num2istr((finx - startx)/(stepmultiple*0.076)) + " points per line? Remember stepmultiple is a multiple of minimum DAC step (0.76mV)"		if(V_flag == 2)			abort "Good choice"		endif	endif	numptsx = round(abs((finx-startx)/(stepmultiple*0.076)))		  		if(paramisdefault(comments))		comments=""	endif		if(paramisdefault(x1) || paramisdefault(x2) || paramisdefault(y1) || paramisdefault(y2))		variable sy, numx		wave i_sense //uses charge transition to find positions and gradient		print "Scanning two lines to calculate initial gradient and transition coords"		numx = round(abs(startx-finx)/5 < 100 ? 100 : abs(startx - finx)/3) //shorthand if else. numx is larger of 100points or every 5mV		sy = starty < finy ? starty : finy //short if else statement. sets sy to lower of starty/finy		rampmultiplebd(instrID, channelsy, sy, ramprate = 1000) 		scanbabydac(instrID, finx-abs(finx-startx)/4, finx, channelsx, numx/4, delayx, 1000, nosave = 1) //1 point per mV, first assuming transition is in last 1/4		//x1 = fitcharge1d(i_sense)		x1 = findtransitionmid(i_sense)		if(numtype(x1) == 2) //if didn't find it there, try other 3/4			scanbabydac(instrID, startx, startx+3*abs(finx-startx)/4, channelsx, numx*3/4, delayx, 1000, nosave = 1) //1 point per mV			//x1 = fitcharge1d(i_sense)			x1 = findtransitionmid(i_sense)			if(numtype(x1) == 2)				abort "failed to find charge transition in first row"			endif		endif		y1 = sy		rampmultiplebd(instrID, channelsy, sy+5, ramprate = 1000)		scanbabydac(instrID, x1-100, x1+20, channelsx, 101, delayx, 1000, nosave = 1) //only checks near to previous transition		//x2 = fitcharge1d(i_sense)		x2 = findtransitionmid(i_sense)		if(numtype(x2) == 2)			abort "failed to find charge transition at first row +5mV"		endif		y2 = sy+5		print "x1 = " + num2str(x1) + ", " + "y1 = " + num2str(y1) + ", " + "x2 = " + num2str(x2) + ", " + "y2 = " + num2str(y2) //useful if you want to run the same scan multiple times	endif		VKS = replacenumberbykey("x1", VKS, x1)	VKS = replacenumberbykey("x2", VKS, x2)	VKS = replacenumberbykey("y1", VKS, y1)	VKS = replacenumberbykey("y2", VKS, y2)	VKS = replacenumberbykey("w", VKS, width)	//VKS = replacenumberbykey("n", VKS, 0) 		//used by Cut2Dline for adapting line    	sprintf x_label, "BD %s (mV)", channelsx	sprintf y_label, "BD %s (mV)", channelsy		InitializeWaves(startx, finx, numptsx, starty=starty, finy=finy, numptsy=numptsy, x_label=x_label, y_label=y_label, linecut=linecut)	sc_sleep(1.0)    	// main loop	do		j=0		setpointx = startx		setpointy = starty + (i*(finy-starty)/(numptsy-1))				do			setpointx = startx + (j*(finx-startx)/(numptsx-1))			if( Cut2Dline(setpointx, setpointy, followtolerance=ft) == 0 )				RecordValues(i, j, fillnan=1)				j+=1			else				break			endif		while( j<numptsx )				if (j == numptsx && i<numptsy-1)			i+=1			continue		elseif (j == numptsx && i >= numptsy-1)			print "No allowed values in final row"			break		endif	  	  	RampMultipleBD(instrID, channelsy, setpointy, ramprate=rampratey)  		RampMultipleBD(instrID, channelsx, setpointx, ramprate=rampratex)		sc_sleep(delayy)				do		  setpointx = startx + (j*(finx-startx)/(numptsx-1))		  if( Cut2Dline(setpointx, setpointy) == 0 )		     RecordValues(i, j, fillnan=1)		  else    		  RampMultipleBD(instrID, channelsx, setpointx, ramprate=rampratex)		     sc_sleep(delayx)		     RecordValues(i, j)		  endif		  j+=1		while (j<numptsx)		// tell cutfunc another line is completed		i+=1		VKS = ReplaceNumberByKey("n", VKS, i) //Tells cut func which row has finished being scanned	while (i<numptsy)	  SaveWaves(msg=comments)endfunction fitentropy(datnum)	variable datnum	string datname	datname = "dat"+num2str(datnum)+"g2x2d"	wave dat=$datname  // sets dat to be dat...g2x2d		variable Vmid, theta, const, dS, dT	variable i=0, datnumber	wave w_sigma //for collecting erros from FuncFit	make /O /N=(dimsize(dat,0)) datrow	SetScale/P x dimoffset(dat,0),dimdelta(dat,0),"", datrow		killwaves/z fitdata	make/D /O /N=(dimsize(dat,1), 6, 3) fitdata  //last column is for storing other info like dat number, y scale			//Make/D/N=5/O temp		//W_coef[0] = {-3048,1.2,0,0.5,-0.00045}	//W_coef[0] = {Vmid,theta,const,dS,dT}	make/free/O tempwave =  {{-3048},{1.2},{0},{0.5},{-0.00045},{0}} //gets overwritten with data specific estimates before funcfit	fitdata[][0,4][0] = tempwave[0][q]	fitdata[0][5][0] = datnum	i=0	do		datrow[] = dat[p][i]		fitdata[i][5][2] = dimoffset(dat, 1)+i*dimdelta(dat, 1) // records y values in fitdata for use in plot entropy		wavestats/Q datrow		if (v_npnts < 50 && i < (dimsize(dat,1)-1)) //Send back to beginning if not enough points in datrow			i+=1			continue		elseif (v_npnts < 50 && i >= (dimsize(dat,1)-1))			break		endif		//W_coef[0] = {(v_MinLoc + (V_MaxLoc-V_minLoc)/2),v_maxloc-V_minloc,0,0.5,-0.00040}		fitdata[i][0,4][0] = {{(v_MinLoc + (V_MaxLoc-V_minLoc)/2)},{v_maxloc-V_minloc},{0},{0.5},{-0.00040}}		fitdata[i][0,4][2] = fitdata[i][q][0] //save initial guess in page3		//		FuncFit /Q Entropy1CK W_coef datrow /D 		FuncFit /Q Entropy1CK fitdata[i][0,4][0] datrow 		fitdata[i][0,4][1] = w_sigma[q] //Save errors on page2		i+=1	while (i<dimsize(dat, 1))//	while (i<1)		endfunction fitentropy1D(dat)	wave dat	variable Vmid, theta, const, dS, dT	variable i=0	make /O /N=(5) fitdata		Make/D/N=5/O W_coef		W_coef[0] = {-3048,1.2,0,0.5,-0.00045}	//W_coef[0] = {Vmid,theta,const,dS,dT}	wavestats /Q dat	W_coef[0] = {(v_MinLoc + (V_MaxLoc-V_minLoc)/2),v_maxloc-V_minloc,0,0.5,-0.0080}		display dat	FuncFit /Q Entropy1CK W_coef dat /D 		fitdata[] = w_coef[p]		endFunction Entropy1CK(w,Vp) : FitFunc	Wave w	Variable Vp	//CurveFitDialog/ These comments were created by the Curve Fitting dialog. Altering them will	//CurveFitDialog/ make the function less convenient to work with in the Curve Fitting dialog.	//CurveFitDialog/ Equation:	//CurveFitDialog/ f(Vp) = -(dT)*((Vp-Vmid)/(2*theta)-0.5*dS)*(cosh((Vp-Vmid)/(2*theta)))^(-2)+const	//CurveFitDialog/ End of Equation	//CurveFitDialog/ Independent Variables 1	//CurveFitDialog/ Vp	//CurveFitDialog/ Coefficients 5	//CurveFitDialog/ w[0] = Vmid	//CurveFitDialog/ w[1] = theta	//CurveFitDialog/ w[2] = const	//CurveFitDialog/ w[3] = dS	//CurveFitDialog/ w[4] = dT	return -(w[4])*((Vp-w[0])/(2*w[1])-0.5*w[3])*(cosh((Vp-w[0])/(2*w[1])))^(-2)+w[2]Endfunction makeEntropyFitWave(dat,row,fitdata)	wave dat, fitdata	variable row			make /O /N=(dimsize(dat,0)) datxval	make /O /N=(dimsize(dat,0)) fitwave		SetScale/P x dimoffset(dat,0),dimdelta(dat,0),"", datxval	datxval =x	SetScale/P x dimoffset(dat,0),dimdelta(dat,0),"", fitwave	make /O /N=5 coefs	coefs[0,4]=fitdata[row][p][0]		int i=0	variable x=0		do		fitwave[i]= Entropy1CK(coefs, datxval[i])		i+=1	while (i<dimsize(dat,0))	endfunction seefit(row)	variable row		wave fitdata	string datname	datname = "dat"+num2str(fitdata[0][5][0])+"g2x2d" //grabs datnumber from fitdata	wave dat=$datname  // sets dat to be dat...g2x2d		wave fitwave	//killwindow/Z SeeEntropyFit	display/N=SeeEntropyFit dat[][row] 	makeentropyfitwave(dat,row,fitdata)	appendtograph fitwave	ModifyGraph rgb(fitwave)=(0,0,65535)	setaxis bottom fitdata[row][0][0]-15, fitdata[row][0][0]+15   // reasonable axis around centre point 	TextBox/C/N=text0/A=LT "Dat"+num2str(fitdata[0][5][0])+" BD13: "+num2str(fitdata[row][5][2])+"mV"	Label left "g2x"	Label bottom "Small Plunger /mV"Endfunction PlotEntropy([ErrorCutOff])		variable ErrorCutOff	wave fitdata	variable i=0		duplicate/O fitdata displaydata  //should make a wave with just the dimension it needs TODO		if (paramisdefault(ErrorCutOff))		errorcutoff = 0.5	endif		do		if (fitdata[i][3][1] > errorcutoff || abs(fitdata[i][3][0]) > 10) // remove unreliable entropy values			displaydata[i][3][0] = NaN		endif		i+=1	while (i<dimsize(fitdata,0))		setscale/P x, fitdata[0][5][2], (fitdata[1][5][2]-fitdata[0][5][2]), displaydata // sets scale to y scale of original data	dowindow/K EntropyPlot	display/N=EntropyPlot displaydata[][3][0]	ErrorBars displaydata Y,wave=(displaydata[*][3][1],displaydata[*][3][1])	Label left "Entropy/Kb"	TextBox/C/N=text0/A=MT "dat"+num2str(fitdata[0][5][0]) //prints datnumber stored in 050	Label bottom "BD13 /mV"	make/O/N=(dimsize(displaydata,0)) tempwave = ln(2)	setscale/P x, fitdata[0][5][2], (fitdata[1][5][2]-fitdata[0][5][2]), tempwave 	appendtograph tempwave	ModifyGraph rgb(tempwave)=(0,0,65535), grid(bottom)=1,minor(bottom)=1,gridRGB(bottom)=(24576,24576,65535,32767), nticks(bottom)=10,minor=0	endfunction FindTransitionMid(dat)	wave dat	variable MinVal, MinLoc, w, lower, upper	wavestats/Q dat //easy way to get num notNaNs	w = V_npnts/20 //width to smooth by (relative to how many datapoints taken)	redimension/N=-1 dat	smooth w, dat	//Smooth dat so differentiate works better	differentiate dat /D=datdiff	wavestats/Q datdiff	MinVal = V_min  		//Will get overwritten by next wavestats otherwise	MinLoc = V_minLoc 	//	Findvalue/V=(minVal)/T=(abs(minval/100)) datdiff //find index of min peak	lower = V_value-w*1.5 //Region to cut from datdiff	upper = V_value+w*1.5 //same	if(lower < 1)		lower = 0 //make sure it doesn't exceed datdiff index range	endif	if(upper > numpnts(datdiff)-2)		upper = numpnts(datdiff)-1 //same	endif	datdiff[lower, upper] = NaN //Remove peak	wavestats/Q datdiff //calc V_adev without peak			if(abs(MinVal/V_adev)>10)		return MinLoc	else		print "MinVal/V_adev = " + num2str(abs(MinVal/V_adev)) + ", at " + num2str(minval) + "mV"		return NaN	endifend		function fitcharge1D(dat)	wave dat	variable Vmid, w	redimension/N=-1 dat	duplicate/FREE dat datSmooth	wavestats/Q/M=1 dat //easy way to get num notNaNs (M=1 only calculates a few wavestats)	w = V_npnts/10 //width to smooth by (relative to how many datapoints taken)	smooth w, datSmooth	//Smooth dat so differentiate works better	differentiate datSmooth /D=datdiff	wavestats/Q/M=1 datdiff	Vmid = V_minloc 		Make/D/O/N=5 W_coef	wavestats/Q/M=1/R=(Vmid-10,Vmid+10) dat //wavestats close to the transition (in mV, not dat points)					//Scale y,   y offset, theta(width), mid, tilt	w_coef[0] = {-(v_max-v_min), v_avg, 	abs((v_maxloc-v_minloc)/10), 	Vmid, 0} //TODO: Check theta is a good estimate	duplicate/O w_coef w_coeftemp //TODO: make /FREE	funcFit/Q Chargetransition W_coef dat /D	wave w_sigma		if(w_sigma[3] < 0.5) //Check Vmid was a good fit (some areas <0.03 consistently)		return w_coef[3]	endif	make/O/N=2 cm_coef = 0	duplicate/O/R=(-inf, vmid-5) dat datline //so hopefully just the gradient of the line leading up to the transition and not including the transition	curvefit/Q line kwCWave = cm_coef datline /D	w_coef = w_coeftemp	w_coef[1] = cm_coef[0]	w_coef[4] = cm_coef[1]	funcFit/Q Chargetransition W_coef dat /D	//try again with new set of w_coef	if	(w_sigma[3] < 0.5)		return w_coef[3]	else		return NaN	endifendfunction fitchargetransition(dat)	wave dat	variable G2, Vmid, G0, theta, gam	variable i=0		make /O /N=(dimsize(dat,1)) datrow	SetScale/P x dimoffset(dat,1),dimdelta(dat,1),"", datrow	Make/D/N=5/O W_coef	W_coef[0] = {0.1e-9,1.64e-9,3,-3412,0}		make /O /N=(dimsize(dat,0), 5) fitdata		do		datrow[] = dat[i][p]		wavestats /Q datrow		w_coef[0] = {(v_max-v_min), v_avg, 0.1, (v_maxLoc+(V_maxLoc-V_minLoc)/2),0}				FuncFit /Q Chargetransition W_coef datrow /D 				fitdata[i][] = w_coef[q]		i+=1	while (i<dimsize(dat, 0))EndFunction Chargetransition(w,x) : FitFunc	Wave w	Variable x	//CurveFitDialog/ These comments were created by the Curve Fitting dialog. Altering them will	//CurveFitDialog/ make the function less convenient to work with in the Curve Fitting dialog.	//CurveFitDialog/ Equation:	//CurveFitDialog/ f(x) = G0*tanh((x - Vmid)/(2*Theta)) + gamma*x + G2	//CurveFitDialog/ End of Equation	//CurveFitDialog/ Independent Variables 1	//CurveFitDialog/ x	//CurveFitDialog/ Coefficients 5	//CurveFitDialog/ w[0] = G0	//CurveFitDialog/ w[1] = G2	//CurveFitDialog/ w[2] = Theta	//CurveFitDialog/ w[3] = Vmid	//CurveFitDialog/ w[4] = gamma	return w[0]*tanh((x - w[3])/(2*w[2])) + w[4]*x + w[1]Endfunction shiftdata(datawave)   //shifts data left until no more NaN's	wave datawave	int shift, i	make /o /n=(numpnts(datawave)) outwave	for (i=0; numtype(datawave[i])==2;i+=1)	endfor		shift = -i		for (i=0; i <= (numpnts(datawave)-1+shift); i+=1)		outwave[i] = datawave[i-shift]	endfor		for (i=i; i <= numpnts(datawave)-1; i+=1)		outwave[i] = nan	endfor	datawave = outwaveend //Takes a 2D wave, differentiates in either x or y direction, then plots troughs of differentiated wave as 0s or 1s. Planning to make do a linear fit to that.function graddif(data, vertical, [threshlow, startx, finx, starty, finy]) // vertical = 0 >> differentiate horizontally																				// vertical = 1 >> differentiate vertically	wave data	int vertical	variable threshlow, startx, finx, starty, finy									duplicate /O data dat		if (paramisdefault(startx))		startx = 0	endif	if (paramisdefault(finx))		finx = dimsize(dat, 1)	endif	if (paramisdefault(starty))		starty = 0	endif	if (paramisdefault(finy))		finy = dimsize(dat,0)	endif		make /O /N=(finy-starty, finx-startx)  fitwave			Differentiate/DIM=(vertical) dat/D=datdif						//$(nameofwave(dat)+"_dif")			if (paramisdefault(threshlow))		threshlow = 0.5*wavemin(datdif)     //may want to play with ratio value. wavemin because differentiated waves have troughs	endif	Display;AppendImage datdif			int i, j		for (j=starty; j<=finy-1; j+=1)		for (i=startx; i<=finx-1; i+=1)				if (datdif[j][i]>threshlow)				fitwave[j][i] = 0			elseif (datdif[j][i]<=threshlow)				fitwave[j][i] = 1			else 				fitwave[j][i] = nan			endif		endfor	endfor	//display; appendimage fitwave		end	//////////////////////////////Macros///////////////////////////////////macro ScanAtNewTemp()		setLS370exclusivereader(ls370,"bfsmall_mc")	setLS370PIDcontrol(ls370,6,40,1.0)	sc_sleep(2.0)		WaitTillTempStable(ls370, 40, 5, 20, 0.10)	sc_sleep(60.0)	ScanBabyDac2DLine(bd6, -4000, -1800, "12", 1, 0.1, 1000, -850, -500, "13", 701, 1.0, 1000, 12, linecut=1, followtolerance = 0.10, x1 = -1945.1, y1 = -850, x2 = -1969.5, y2 = -845)endMacro fine5for01transition()	//DAC 5, 11, 14, 15 at -350, -867, -325, -1030 respectively	ScanBabyDac2DLine(bd6, -2250, -1650, "12", 6001, 0.2, 1000, -850, -750, "13", 101, 1.0, 1000, -2179, -750, -1821, -830, 30)	print "finished -850 to -750mV"	ScanBabyDac2DLine(bd6, -2700, -2100, "12", 6001, 0.2, 1000, -750, -650, "13", 101, 1.0, 1000, -2630, -650, -2178, -750, 30)	print "finished -750 to -650mV"		ScanBabyDac2DLine(bd6, -3150, -2550, "12", 6001, 0.2, 1000, -650, -550, "13", 101, 1.0, 1000, -3080, -550, -2626, -650, 30)	print "finished -650 to -550mV"	ScanBabyDac2DLine(bd6, -3600, -3000, "12", 6001, 0.2, 1000, -550, -450, "13", 101, 1.0, 1000, -3555, -450, -3221, -520, 30)	print "finished -550 to -450mV"	ScanBabyDac2DLine(bd6, -4100, -3500, "12", 6001, 0.2, 1000, -450, -350, "13", 101, 1.0, 1000, -3852, -390, -3555, -450, 30)	print "finished -450 to -350mV"	end			-3976, -360, -2808,-600endMacro linetransition2()	ScanBabyDac2DLine(bd6, -3100, -2700, "12", 4001, 0.3, 1000, -615, -565, "13", 26, 3.0, 1000, -3003.9, -569, -2790.6, -615, 30)	Print "Finished BD5 @ -310"	rampMultipleBD(bd6, "5", -300, ramprate=1000)	ScanBabyDac2DLine(bd6, -3100, -2700, "12", 4001, 0.3, 1000, -615, -565, "13", 26, 3.0, 1000, -2968.9, -577, -2794.4, -615, 30)	Print "Finished BD5 @ -300"	endmacro Linetransition()	ScanBabyDac2DLine(bd6, -3000, -2000, "12", 10001, 0.1, 1000, -650, -575, "13", 26, 3.0, 1000, -2780, -560, -2404, -640, 30)	Print "Finished thin (30) line BD15 @ -1030"	ScanBabyDac2DLine(bd6, -3000, -2000, "12", 3001, 0.1, 1000, -650, -575, "13", 26, 3.0, 1000, -2780, -560, -2404, -640, 100);	Print "Finished thick (100) line BD15 @ -1030"	ScanBabyDac2D(    bd6, -3000, -2000, "12", 501, 0.1, 1000, -650, -575, "13", 26, 3.0, 1000)	Print "Finished 2D BD15 @ -1030"//	rampmultipleBD(bd6, "15", -1025, ramprate=1000)//	ScanBabyDac2DLine(bd6, -3000, -2000, "12", 10001, 0.1, 1000, -650, -575, "13", 26, 3.0, 1000, -2780, -560, -2404, -640, 30)//	Print "Finished thin line (30) BD15 @ -1025"//	ScanBabyDac2DLine(bd6, -3000, -2000, "12", 3001, 0.1, 1000, -650, -575, "13", 26, 3.0, 1000, -2780, -560, -2404, -640, 100);//	Print "Finished thick (100) line BD15 @ -1025"//	ScanBabyDac2D(    bd6, -3000, -2000, "12", 501, 0.1, 1000, -650, -575, "13", 26, 3.0, 1000)//	Print "Finished 2D BD15 @ -1025"endfunction RampOrigin2(instrID)variable instrID	RampMultipleBD(instrID, "8", -2204, ramprate=500)	RampMultipleBD(instrID, "11", -275, ramprate=500)	RampMultipleBD(instrID, "12", -4086, ramprate=500)	RampMultipleBD(instrID, "13", -390, ramprate=500)endFunction virtualgates2(instrID)	variable instrID//	RampOrigin2(instrID)//	sc_sleep(4.0)//	RampMultipleBD(instrID, "8", -2194, ramprate=500)//	Scanbabydac2D(instrID, -4101, -4074, "12", 201, 0.1, 1000, -271.5, -277.5, "11", 31, 0.3, 1000)//	Print "Finished scan BD12 vs BD11"//	//	//	RampOrigin2(instrID)//	RampMultipleBD(instrID, "8", -2194, ramprate=500)//	sc_sleep(4.0)//	Scanbabydac2D(instrID, -4086-30, -4086+30, "12", 201, 0.1, 1000, -390-8, -390+5, "13", 31, 0.3, 1000)//   Print "Finished scan BD12 vs BD13"//      	RampOrigin2(instrID)	sc_sleep(4.0)	Scanbabydac2D(instrID, -4092, -4078, "12", 201, 0.1, 1000, -2221.5, -2184.5, "8", 51, 0.3, 1000)   Print "Finished scan BD8 vs BD12"      RampOrigin2(instrID)	RampMultipleBD(instrID, "12", -4095, ramprate=500)	sc_sleep(4.0)	Scanbabydac2D(instrID, -2206, -2186, "8", 251, 0.1, 1000, -273.75, -277, "11", 51, 0.3, 1000)   Print "Finished scan BD11 vs BD8"   RampOrigin2(instrID)	RampMultipleBD(instrID, "12", -4095, ramprate=500)	sc_sleep(4.0)	Scanbabydac2D(instrID, -2199, -2179, "8", 251, 0.1, 1000, -401, -390, "13", 51, 0.3, 1000)	Print "Finished scan BD13 vs BD8"	endmacro VirtualVP1VP2both()			ScanVirtualGates2D(bd6, -20, 20, "VP1", 201, 0.1, -30, 30, "VP2", 51, 0.3)	print "Finished Scanning VP2 vs VP1"		sc_Sleep(5.0)	ScanVirtualGates2D(bd6, -30, 30, "VP2", 201, 0.1, -20, 20, "VP1", 51, 0.3)	print "Finished Scanning VP1 vs VP2"		getSlackNotice("U8W2V6QK0", message="finished!") 	//getSlackNotice("nik.hartman", message="Both VP2vsVP1 and VP1vsVP2 are finished") endmacro stepPerField_measure()		setLS625fieldWait(magy,20)	ScanBabyDACRepeat(bd6, -3412-10, -3412+10, "12", 201, 0.1, 1000, 6, 1.0)		setLS625fieldWait(magy,15)	ScanBabyDACRepeat(bd6, -3412-10, -3412+10, "12", 201, 0.1, 1000, 6, 1.0)		setLS625fieldWait(magy,10)	ScanBabyDACRepeat(bd6, -3412-10, -3412+10, "12", 201, 0.1, 1000, 6, 1.0)		setLS625fieldWait(magy,5)	ScanBabyDACRepeat(bd6, -3412-10, -3412+10, "12", 201, 0.1, 1000, 6, 1.0)		setLS625fieldWait(magy,0)	ScanBabyDACRepeat(bd6, -3412-10, -3412+10, "12", 201, 0.1, 1000, 6, 1.0)macro VG1VP1SliceRepeat()	ScanVirtualGateRepeat(bd6, -20, 5, "VP1", 251, 0.1, 10, 0.3, vp2=4, vg1=-150)	Print "Finished Scan with VG1 at -150"		ScanVirtualGateRepeat(bd6, -20, 5, "VP1", 251, 0.1, 10, 0.3, vp2=4, vg1=-130)	Print "Finished Scan with VG1 at -130"		ScanVirtualGateRepeat(bd6, -20, 5, "VP1", 251, 0.1, 10, 0.3, vp2=4, vg1=-110)	Print "Finished Scan with VG1 at -110"		ScanVirtualGateRepeat(bd6, -20, 5, "VP1", 251, 0.1, 10, 0.3, vp2=4, vg1=-90)	Print "Finished Scan with VG1 at -90"		ScanVirtualGateRepeat(bd6, -20, 5, "VP1", 251, 0.1, 10, 0.3, vp2=4, vg1=-70)	Print "Finished Scan with VG1 at -70"		ScanVirtualGateRepeat(bd6, -20, 5, "VP1", 251, 0.1, 10, 0.3, vp2=4, vg1=-50)	Print "Finished Scan with VG1 at -50"		ScanVirtualGateRepeat(bd6, -20, 5, "VP1", 251, 0.1, 10, 0.3, vp2=4, vg1=-30)	Print "Finished Scan with VG1 at -30"		ScanVirtualGateRepeat(bd6, -20, 5, "VP1", 251, 0.1, 10, 0.3, vp2=4, vg1=-10)	Print "Finished Scan with VG1 at -10"	endmacro VG1FineScan()//	ScanVirtualGates2D(bd6, -20, 5, "VP1", 251, 0.1, -150, -100, "VG1", 150, 1.0, vp2=4)//	print "Finished from -150mV to -100mV"	//	ScanVirtualGates2D(bd6, -20, 5, "VP1", 251, 0.1, -100, -50, "VG1", 150, 1.0, vp2=4)//	print "Finished from -100mV to -50mV"	//	ScanVirtualGates2D(bd6, -20, 5, "VP1", 251, 0.1, -50, 0, "VG1", 150, 1.0, vp2=4)//	print "Finished from -50mV to 0mV"	ScanVirtualGates2D(bd6, -25, 0, "VP1", 251, 0.1, 0, 20, "VG1", 60, 1.0, vp2=4)	print "Finished from 0mV to 20mV"		ScanVirtualGates2D(bd6, -25, 0, "VP1", 251, 0.1, 20, 40, "VG1", 60, 1.0, vp2=4)	print "Finished from 20mV to 40mV"		ScanVirtualGates2D(bd6, -25, 0, "VP1", 251, 0.1, 40, 60, "VG1", 60, 1.0, vp2=4)	print "Finished from 40mV to 60mV"end	function RampOrigin3(instrID)variable instrID	RampMultipleBD(instrID, "11", -250, ramprate=500) //big dot coupling	RampMultipleBD(instrID, "12", -450, ramprate=500) //small dot plunger	RampMultipleBD(instrID, "13", -600, ramprate=500) //res coupling	RampMultipleBD(instrID, "14", -325, ramprate=500) //spine	RampMultipleBD(instrID, "3", 0, ramprate=500)		  //accumulation gateendfunction SmalldotGatesvsAcc(instrID)	variable instrID	RampOrigin3(instrID)	RampMultipleBD(instrID, "3", 40, ramprate=100)	ScanbabyDAC2D(instrID, -200, -1100, "11", 241, 0.05, 1000, -300, -1300, "13", 121, 0.3, 1000)	print "Finished accumulation: +40mV, SP: -450mV"	RampOrigin3(instrID)	RampMultipleBD(instrID, "3", 20, ramprate=100)	ScanbabyDAC2D(instrID, -200, -1100, "11", 241, 0.05, 1000, -300, -1300, "13", 121, 0.3, 1000)	print "Finished accumulation: +20mV, SP: -450mV"		RampOrigin3(instrID)	RampMultipleBD(instrID, "3", 0, ramprate=100)	ScanbabyDAC2D(instrID, -200, -1100, "11", 241, 0.05, 1000, -300, -1300, "13", 121, 0.3, 1000)	print "Finished accumulation: 0mV, SP: -450mV"		RampOrigin3(instrID)	RampMultipleBD(instrID, "3", -20, ramprate=100)	ScanbabyDAC2D(instrID, -200, -1100, "11", 241, 0.05, 1000, -300, -1300, "13", 121, 0.3, 1000)	print "Finished accumulation: -20mV, SP: -450mV"	RampOrigin3(instrID)	RampMultipleBD(instrID, "3", -40, ramprate=100)	ScanbabyDAC2D(instrID, -200, -1100, "11", 241, 0.05, 1000, -300, -1300, "13", 121, 0.3, 1000)	print "Finished accumulation: -40mV, SP: -450mV"	RampOrigin3(instrID)	RampMultipleBD(instrID, "3", +40, ramprate=100)	RampMultipleBD(instrID, "12", -650, ramprate=100)	ScanbabyDAC2D(instrID, -200, -1100, "11", 241, 0.05, 1000, -300, -1300, "13", 121, 0.3, 1000)	print "Finished accumulation: +40mV, SP: -650mV"		RampOrigin3(instrID)	RampMultipleBD(instrID, "3", 20, ramprate=100)	RampMultipleBD(instrID, "12", -650, ramprate=100)	ScanbabyDAC2D(instrID, -200, -1100, "11", 241, 0.05, 1000, -300, -1300, "13", 121, 0.3, 1000)	print "Finished accumulation: +20mV, SP: -650mV"		RampOrigin3(instrID)	RampMultipleBD(instrID, "3", 0, ramprate=100)	RampMultipleBD(instrID, "12", -650, ramprate=100)	ScanbabyDAC2D(instrID, -200, -1100, "11", 241, 0.05, 1000, -300, -1300, "13", 121, 0.3, 1000)	print "Finished accumulation: 0mV, SP: -650mV"		RampOrigin3(instrID)	RampMultipleBD(instrID, "3", -20, ramprate=100)	RampMultipleBD(instrID, "12", -650, ramprate=100)	ScanbabyDAC2D(instrID, -200, -1100, "11", 241, 0.05, 1000, -300, -1300, "13", 121, 0.3, 1000)	print "Finished accumulation: -20mV, SP: -650mV"	RampOrigin3(instrID)	RampMultipleBD(instrID, "3", -40, ramprate=100)	RampMultipleBD(instrID, "12", -650, ramprate=100)	ScanbabyDAC2D(instrID, -200, -1100, "11", 241, 0.05, 1000, -300, -1300, "13", 121, 0.3, 1000)	print "Finished accumulation: -40mV, SP: -650mV"		endfunction lineTransitions2D(instrID)	variable instrID	make/O Dac13val = 	 {-550,								 -600, 							-650,							-700,								 -750}	make/O LineCoords = {{-2724.3, -974, -2578.6, -1014},{-2686, -918, -2556, -954},{-2740, -842, -2566, -890},{-2718.6, -790, -2564.3, -830},{-2740,-726,-2554,-774}} //{x1, y1, x2, y2}	make/O ScanWindow = {{-2750, -2550, -1020, -955},	 {-2750, -2550, -955, -900},{-2750, -2550, -890, -835},{-2750, -2550, -830, -780},	  {-2750,-2550,-780,-720}} //{startx, finx, starty, finy}	variable i=0, numptsx, numptsy, width=40 //width of scan line mV		if (numpnts(dac13val) != dimsize(LineCoords, 1))	// check I put in correct no. of initial conditions		abort "No. dac conditions different to no. line coords"	elseif (numpnts(dac13val) != dimsize(Scanwindow, 1))		abort "No. dac conditions different to no. Scan window coords"	endif	i=0	do		rampmultipleBD(instrID, "13", Dac13Val[i], ramprate = 100)		sc_sleep(10.0)		numptsx = ceil(abs((Scanwindow[0][i] - Scanwindow[1][i])*10)) // makes sure 0.1mV per x step		numptsy = ceil(abs((Scanwindow[2][i] - Scanwindow[3][i])/5)) // makes sure 5mV per y step				ScanBabyDac2DLine(instrID, ScanWindow[0][i], ScanWindow[1][i], "12", numptsx, 0.1, 1000, ScanWindow[2][i], ScanWindow[3][i], "11", numptsy, 0.5, 1000, width, x1 = LineCoords[0][i], y1 = LineCoords[1][i], x2 = LineCoords[2][i], y2 = LineCoords[3][i])		print "Finished scan with BD13 @" + num2str(Dac13val[i])		i+=1	while (i<numpnts(Dac13val))end//////////////////////////////////////////// Obsolete //////////////////////////////////////////////////Function Init2DlineWaves(startx, finx, numptsx, starty, finy, numptsy, [x_label, y_label]) //// Does normal Initialize waves for 1D waves, then creates 2D waves for storing line data. //// 2D waves created have no scale in x direction and have only 1 row. They will be redimensioned in RecordValuesLine//// May work to just redimension the 2D waves created by normal initialize waves and set SC_is2d = 2 so record values doesn't do 2d recording////	variable startx, finx, numptsx, starty, finy, numptsy//	string x_label, y_label//	svar sc_y_label, sc_x_label, sc_colormap//	nvar sc_is2d, sc_numptsy, sc_numptsx, sc_startx, sc_finx, sc_starty, sc_startx, sc_finy, sc_finx//	string cmd = ""//	wave sc_RawRecord, sc_CalcRecord, sc_RawPlot, sc_CalcPlot//	wave/T sc_RawWaveNames, sc_CalcWaveNames//	//	InitializeWaves(startx, finx, numptsx, x_label=x_label) //Initializes 1D waves normally (sc_is2d=0) //	make/O/n=(numptsy) sc_linestart = NaN 						//To store first xvalue of each line of data//	cmd = "setscale/I x " + num2str(sc_starty) + ", " + num2str(sc_finy) + ", " + "sc_linestart"; execute(cmd)//	////	sc_is2d = 2 //Tells record values to record as 2Dline	//	sc_starty = starty//	sc_finy = finy//	sc_numptsy = numptsy//	if(starty==finy) //won't be caught in 1D initialize waves//		print "[WARNING]: Your start and end y values are the same!"//	endif//	//	if(paramisdefault(y_label) || stringmatch(y_label,""))//		sc_y_label=""//	else//		sc_y_label=y_label//	endif//	//	//make ydata (xdata already made in initializewaves)//	cmd = "make /o/n=(" + num2istr(sc_numptsy) + ") " + "sc_ydata" + "=NaN"; execute(cmd)//	cmd = "setscale/I x " + num2str(sc_starty) + ", " + num2str(sc_finy) + ", \"\", " + "sc_ydata"; execute(cmd)//	cmd = "sc_ydata" +" = x"; execute(cmd)//	//	variable i=0//	string wn="",  wn2d = ""//	//Initialize waves for raw data//	do//		if (sc_RawRecord[i] == 1 && cmpstr(sc_RawWaveNames[i], "") || sc_RawPlot[i] == 1 && cmpstr(sc_RawWaveNames[i], ""))//			wn2d = sc_RawWaveNames[i]+"2d"////////////What InitializeWaves is doing////			cmd = "make /o/n=(" + num2istr(sc_numptsx) + ") " + wn + "=NaN"////			execute(cmd)////			cmd = "setscale/I x " + num2str(sc_startx) + ", " + num2str(sc_finx) + ", \"\", " + wn////			execute(cmd)//////////////			cmd = "make /o/n=(1, " + num2istr(sc_numptsy) + ") " + wn2d + "=NaN"; execute(cmd) //Makes 1 by y wave, x is redimensioned in recordline//			cmd = "setscale /P x, 0, " + num2str((sc_finx-sc_startx)/sc_numptsx) + "," + wn2d; execute(cmd) //sets x scale starting from 0 but with delta correct	//			cmd = "setscale /i y, " + num2str(sc_starty) + ", " + num2str(sc_finy) + ", " + wn2d; execute(cmd)//Useful to see if top and bottom of scan are filled with NaNs//		endif//		i+=1//	while (i<numpnts(sc_RawWaveNames))	//	//Initialize waves for Calculated data//	i=0//	do//		if (sc_CalcRecord[i] == 1 && cmpstr(sc_CalcWaveNames[i], "") || sc_CalcPlot[i] == 1 && cmpstr(sc_CalcWaveNames[i], ""))//			wn2d = sc_CalcWaveNames[i]+"2d"//			cmd = "make /o/n=(1, " + num2istr(sc_numptsy) + ") " + wn2d + "=NaN"; execute(cmd) //Same as for Raw (see above)	//			cmd = "setscale /P x, 0, " + num2str((sc_finx-sc_startx)/sc_numptsx) + "," + wn2d; execute(cmd) //sets x scale starting from 0 but with delta correct		//			cmd = "setscale /i y, " + num2str(sc_starty) + ", " + num2str(sc_finy) + ", " + wn2d; execute(cmd)//			//		endif//		i+=1//	while (i<numpnts(sc_CalcWaveNames))//	//	///////////////////////////////////	/////////////////////////////////// Same as regular initializewaves	//	string graphlist = "", graphname = "", graphtitle = "", plottitle = "", graphnumlist = "", graphnum = "", activegraphs = ""//	variable j, index=0, graphopen=0, graphopen2D=0//	// Find all open plots//	graphlist = winlist("*",";","WIN:1")//	j=0 //	//for (i=0;i<round(strlen(graphlist)/6);i=i+1)  //Tim:TODO: is /6 because you're assuming graph** and it's roughly 6 characters?//	for (i=0;i<itemsinlist(graphlist);i=i+1) 	//		index = strsearch(graphlist,";",j)//		graphname = graphlist[j,index-1]//		setaxis/w=$graphname /a//		getwindow $graphname wtitle//		splitstring /e="(.*):(.*)" s_value, graphnum, plottitle//		graphtitle+= plottitle+";"//		graphnumlist+= graphnum+";"//		j=index+1//	endfor////	//Initialize plots for raw data waves//	i=0//	do//		if (sc_RawPlot[i] == 1 && cmpstr(sc_RawWaveNames[i], ""))//			wn = sc_RawWaveNames[i]//			graphopen = 0//			graphopen2d = 0//			for(j=0;j<ItemsInList(graphtitle);j=j+1)//				if(stringmatch(wn,stringfromlist(j,graphtitle)))//					graphopen = 1//					activegraphs+= stringfromlist(j,graphnumlist)+";"//					Label /W=$stringfromlist(j,graphnumlist) bottom,  sc_x_label//				endif//				if(sc_is2d)//					if(stringmatch(wn+"2d",stringfromlist(j,graphtitle)))//						graphopen2d = 1//						activegraphs+= stringfromlist(j,graphnumlist)+";"//						Label /W=$stringfromlist(j,graphnumlist) bottom,  sc_x_label//						Label /W=$stringfromlist(j,graphnumlist) left,  sc_y_label//					endif//				endif//			endfor//			if(graphopen && graphopen2d)//			elseif(graphopen2d)//				display $wn//				setwindow kwTopWin, enablehiresdraw=3//				Label bottom, sc_x_label//				activegraphs+= winname(0,1)+";"//			elseif(graphopen)//				if(sc_is2d)//					wn2d = wn + "2d"//					display//					setwindow kwTopWin, enablehiresdraw=3//					appendimage $wn2d//					modifyimage $wn2d ctab={*, *, $sc_ColorMap, 0}//					colorscale /c/n=$sc_ColorMap /e/a=rc//					Label left, sc_y_label//					Label bottom, sc_x_label//					activegraphs+= winname(0,1)+";"//				endif//			else//				wn2d = wn + "2d"//				display $wn//				setwindow kwTopWin, enablehiresdraw=3//				Label bottom, sc_x_label//				activegraphs+= winname(0,1)+";"//				if(sc_is2d)//					display//					setwindow kwTopWin, enablehiresdraw=3//					appendimage $wn2d//					modifyimage $wn2d ctab={*, *, $sc_ColorMap, 0}//					colorscale /c/n=$sc_ColorMap /e/a=rc//					Label left, sc_y_label//					Label bottom, sc_x_label//					activegraphs+= winname(0,1)+";"//				endif//			endif//		endif//		i+= 1//	while(i<numpnts(sc_RawWaveNames))////	//Initialize plots for calculated data waves//	i=0//	do//		if (sc_CalcPlot[i] == 1 && cmpstr(sc_CalcWaveNames[i], ""))//			wn = sc_CalcWaveNames[i]//			graphopen = 0//			graphopen2d = 0//			for(j=0;j<ItemsInList(graphtitle);j=j+1)//				if(stringmatch(wn,stringfromlist(j,graphtitle)))//					graphopen = 1//					activegraphs+= stringfromlist(j,graphnumlist)+";"//					Label /W=$stringfromlist(j,graphnumlist) bottom,  sc_x_label//				endif//				if(sc_is2d)//					if(stringmatch(wn+"2d",stringfromlist(j,graphtitle)))//						graphopen2d = 1//						activegraphs+= stringfromlist(j,graphnumlist)+";"//						Label /W=$stringfromlist(j,graphnumlist) bottom,  sc_x_label//						Label /W=$stringfromlist(j,graphnumlist) left,  sc_y_label//					endif//				endif//			endfor//			if(graphopen && graphopen2d)//			elseif(graphopen2d)//				display $wn//				setwindow kwTopWin, enablehiresdraw=3//				Label bottom, sc_x_label//				activegraphs+= winname(0,1)+";"//			elseif(graphopen)//				if(sc_is2d)//					wn2d = wn + "2d"//					display//					setwindow kwTopWin, enablehiresdraw=3//					appendimage $wn2d//					modifyimage $wn2d ctab={*, *, $sc_ColorMap, 0}//					colorscale /c/n=$sc_ColorMap /e/a=rc//					Label left, sc_y_label//					Label bottom, sc_x_label//					activegraphs+= winname(0,1)+";"//				endif//			else//				wn2d = wn + "2d"//				display $wn//				setwindow kwTopWin, enablehiresdraw=3//				Label bottom, sc_x_label//				activegraphs+= winname(0,1)+";"//				if(sc_is2d)//					display//					setwindow kwTopWin, enablehiresdraw=3//					appendimage $wn2d//					modifyimage $wn2d ctab={*, *, $sc_ColorMap, 0}//					colorscale /c/n=$sc_ColorMap /e/a=rc//					Label left, sc_y_label//					Label bottom, sc_x_label//					activegraphs+= winname(0,1)+";"//				endif//			endif//		endif//		i+= 1//	while(i<numpnts(sc_CalcWaveNames))////////////////////////////////////////////////////////////////////////////////////////////////////	//execute("abortmeasurementwindow()") //already called in initializewaves////	//	string cmd1 = "TileWindows/O=1/A=(3,4) ", cmd2 = "", window_string = ""//	// Tile graphs//	for(i=0;i<itemsinlist(activegraphs);i=i+1)//		window_string = stringfromlist(i,activegraphs)//		cmd1+= window_string +","////		cmd2 = "DoWindow/F " + window_string//		execute(cmd2)//	endfor////	cmd1 += "SweepControl"//	execute(cmd1)	//end//function testhdf5()////Variable fileID//	HDF5CreateFile/P=<SymbolicPathName> fileID as "test.h5"//	